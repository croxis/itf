#version 400


// FILE: 'Shader/Includes/Configuration.include' 
// This is the main configuration file, included by almost all shaders

// Max values for the light culling
// If you change anything regarding this in LightManager,
// change it here, too
#define MAX_VISIBLE_LIGHTS 25
#define MAX_LIGHTS_PER_PATCH 63

// Same as in LightManager.py
#define MAX_POINT_LIGHTS 16
#define MAX_SHADOW_POINT_LIGHTS 16

// Max shadow maps. Has to be the same as in LightManager.py
#define SHADOW_MAX_TOTAL_MAPS 24


// Wheter to clear the lighting buffer each frame to be
// able to see changes in lighting - only recommended for debugging
#define LIGHTING_CLEAR_BUFFER_EACH_FRAME


// GLSL really needs this as a builtin!
#define saturate(v) clamp(v, 0, 1)

// Needed for light culling
const float sqrt_of_2 = 1.4142135623;

// Load Auto-Config

// FILE: 'Shader/Includes/AutoGeneratedConfig.include' 
// Autogenerated by RenderPipeline.py
// Do not edit! Your changes will be lost.

#define SMAA_PRESET_ULTRA
#define LIGHTING_COMPUTE_PATCH_SIZE_X 32
#define LIGHTING_COMPUTE_PATCH_SIZE_Y 32
#define LIGHTING_MIN_MAX_DEPTH_ACCURACY 1
#define LIGHTING_ANY_BOUND_CHECK 1
#define LIGHTING_ACCURATE_BOUND_CHECK 1
#define USE_SHADOWS 1
#define SHADOW_MAP_ATLAS_SIZE 8192
#define SHADOW_MAX_UPDATES_PER_FRAME 4
#define SHAODOW_GEOMETRY_MAX_VERTICES 12
#define SHADOWS_NUM_SAMPLES 16
#define USE_HARDWARE_PCF 1
#define WINDOW_WIDTH 1600
#define WINDOW_HEIGHT 900
#define USE_MOTION_BLUR 1
#define MOTION_BLUR_SAMPLES 12
#define DSSDO_ENABLED 1
#define DSSDO_NUM_SAMPLES 8
#define DSSDO_RADIUS 1.0
#define DSSDO_MAX_DISTANCE 4.0
#define DSSDO_MAX_ANGLE 0.4
#define DSSDO_STRENGTH 1.3

// Performance functions

// FILE: 'Shader/Includes/Performance.include' 
vec4 FAST_mul(mat4 m, vec3 v) {
    return m * vec4(v, 1);
    // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] + m[3] ));
}

vec4 FAST_mul_no_w(mat4 m, vec3 v) {
    return m * vec4(v, 0);
     // return v.x * m[0] + (v.y * m[1] + (v.z * m[2] ));
}


vec4 FAST_normalize_prefactor(vec4 v) {
    // todo
    return normalize(v);
}

// Wheter to use post-processing blur, this affects DSSDO
#define USE_OCCLUSION_BLUR



#define M_PI 3.14159265



// #pragma optionNV (unroll all)


#define USE_BINDLESS_TEXTURES 0

#if USE_BINDLESS_TEXTURES
    #define BINDLESS layout(bindless_sampler)
#else
    #define BINDLESS
#endif


#ifdef DEBUG_DISABLE_SHADOWS
    #undef USE_SHADOWS
#endif


// panda does not support custom names for bound textures.
// so make it support it, now! :D
#define DIFFUSE_TEX p3d_Texture0
#define NORMAL_TEX p3d_Texture1
#define SPECULAR_TEX p3d_Texture2
#define ROUGHNESS_TEX p3d_Texture3

const ivec2 blurDirection = ivec2(1,0);


// FILE: 'Shader/Includes/PostProcessBlur.include' 
// FILE: 'Shader/Includes/Packing.include' 
// http://aras-p.info/texts/CompactNormalStorage.html
// Packs a normal to a vec2
const float npScale = 1.7777;

vec2 encodeNormal(vec3 n)
{
    vec2 enc = n.xy / (n.z+1.0);
    enc /= npScale;
    return enc*0.5 + 0.5;
}

// Unpacks a normal from a vec2
vec3 decodeNormal(vec2 encoded)
{
    vec3 nn =
        vec3(encoded.xy, 0)*vec3(2*npScale,2*npScale,0) +
        vec3(-npScale,-npScale,1);
    float g = 2.0 / dot(nn.xyz,nn.xyz);
    vec3 n;
    n.xy = g*nn.xy;
    n.z = g-1.0;
    return n;
}

// // Packs float to 2 floats for more precision

// vec2 packDepth(float d) {
//     // return vec2(d, d);
//     return vec2(floor(d*1024), fract(d*1024));
// }

// // Unpacks 2 floats to one high precision float
// float unpackDepth(vec2 d) {
//     // return d.x;
//     return (d.x + d.y) / 1024.0;
// }


const mat3 rgbToYCbCr = mat3(
    0.299, -0.168736, 0.5,
    0.587, -0.331264, -0.418688,
    0.144, 0.5, -0.081312
);

const float expScale = 32.0;
const float yiqBias = 0.125;

vec2 packColor(vec3 color) {
    color = saturate(color);
    vec3 yiq = (rgbToYCbCr * color);
    yiq.y = yiq.y*0.5 + yiqBias;
    yiq = saturate(yiq);
    int exponent = int(yiq.y * expScale);
    float significand =  yiq.z*0.5 + 0.5;
    float pack = ldexp(significand, exponent);
    return vec2(yiq.x, pack);
}

vec3 unpackColor(vec2 pack) {
    int exponent = 0;
    float significand = frexp(pack.y, exponent);

    // todo: MAD
    float i = (float(exponent)) / expScale;
    i = (i - yiqBias) * 2.0;
    float q = significand * 2.0 - 1.0;
    vec3 yiq = vec3(pack.x,i,q);
    vec3 rgb = inverse(rgbToYCbCr) * yiq;
    return rgb;
}


// const float normalsDiscardThreshold = 0.99999;
const float normalsDiscardThreshold = 0.4;


#pragma optionNV (unroll all)


vec4 mipmapBasedBlur(vec2 texcoord, vec2 direction, sampler2D colorTex, sampler2D blurFactors) {

    // return texture(colorTex, texcoord);

    float blurFactor = texture(blurFactors, texcoord).r;

    if (blurFactor < 0.01) {
        return texture(colorTex, texcoord);
    } else {

        float blurWeights[9] = float[9]
        (
            0.013519569015984728,
            0.047662179108871855,
            0.11723004402070096,
            0.20116755999375591,
            0.240841295721373,
            0.20116755999375591,
            0.11723004402070096,
            0.047662179108871855,
            0.013519569015984728
        );

        float offsets[9] = float[9] (-4,-3,-2,-1,0,+1,+2,+3,+4);

        float mipmap = blurFactor * 2.2;
        mipmap = 0.0;
        vec2 texelSize = 7.2 / vec2(textureSize(colorTex, 0));
        texelSize *= direction * blurFactor;
        vec4 result = vec4(0);
        float weights;
        for (int i = 0; i < 9; i++) {
            vec2 offsetCoord = texcoord + offsets[i]*texelSize;
            float dofFactorOffset = textureLod(blurFactors, offsetCoord, 0).r;
            float weight = max(0.0, dofFactorOffset - blurFactor) *  blurWeights[i];
            weight = 1.0;

            result += textureLod(colorTex, offsetCoord , mipmap) *weight;
            weights += weight;
        }
        return result / weights;
    }
}


float edgePreservingAlphaBlur(vec2 texcoord, ivec2 screenCoord, sampler2D colorTex, sampler2D normalTex) {

    #ifndef USE_OCCLUSION_BLUR
        return texture(colorTex, texcoord).a;
    #endif

    #ifdef DSSDO_ENABLED

        float blurWeights[9] = float[9]
        (
            0.013519569015984728,
            0.047662179108871855,
            0.11723004402070096,
            0.20116755999375591,
            0.240841295721373,
            0.20116755999375591,
            0.11723004402070096,
            0.047662179108871855,
            0.013519569015984728
        );

        vec3 normals[9];
        float occlusion[9];

        // AMD Can't handle texelFetchOffset with loops

        #define EPAB_INIT_VALUES(i) \
        normals[i] = decodeNormal(texelFetchOffset(normalTex, screenCoord, 0, ivec2(i-4)*blurDirection).xy); \
        occlusion[i] = texelFetchOffset(colorTex, screenCoord, 0, ivec2(i-4)*blurDirection).a;

        EPAB_INIT_VALUES(0)
        EPAB_INIT_VALUES(1)
        EPAB_INIT_VALUES(2)
        EPAB_INIT_VALUES(3)
        EPAB_INIT_VALUES(4)
        EPAB_INIT_VALUES(5)
        EPAB_INIT_VALUES(6)
        EPAB_INIT_VALUES(7)
        EPAB_INIT_VALUES(8)

        // pixel normal is the mid normal
        vec3 normal = normals[4];

        float alphaResult = 0.0;
        float alphaWeights = 0.0;

        // Check for edges, as we are performing an edge preserving blur
        for (int i = 0; i < 9; i++) {
            float weight = blurWeights[i];
            float normalInfluenceFactor = step(normalsDiscardThreshold, dot(normals[i], normal));
            alphaResult += occlusion[i]*weight*normalInfluenceFactor;
            alphaWeights += weight*normalInfluenceFactor;
        }

        return alphaResult / alphaWeights;


    #else
        return texelFetch(colorTex, screenCoord, 0).a;
    #endif
}

uniform sampler2D colorTex;
uniform sampler2D normalTex;

in vec2 texcoord;

out vec4 result;



void main() {
    vec2 screenSize = vec2(textureSize(colorTex, 0));
    ivec2 screenCoord = ivec2(texcoord * screenSize );
    float blurResult = edgePreservingAlphaBlur(texcoord, screenCoord, colorTex, normalTex);
    vec3 colorResult = texture(colorTex, texcoord).rgb;
    result = vec4(colorResult * blurResult, 1);
    // result = vec4(blurResult);
    // result = vec4(0,0,1,1);
}
